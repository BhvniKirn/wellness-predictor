# -*- coding: utf-8 -*-
"""wellness_predictor.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/17oUK1DkTl06akELg2rt8bEyrfIP8TPZ-
"""

import numpy as np
import pandas as pd

np.random.seed(42)
n_samples = 1500

# Simulated features
heart_rate = np.random.normal(72, 10, n_samples).clip(50, 120)
sleep_hours = np.random.normal(7, 1.5, n_samples).clip(3, 10)
steps = np.random.normal(8000, 2500, n_samples).clip(1000, 20000)
calories = np.random.normal(2200, 500, n_samples).clip(1200, 4000)
screen_time = np.random.normal(5, 2, n_samples).clip(0.5, 12)
hydration = np.random.normal(2.5, 0.8, n_samples).clip(0.5, 5)
bmi = np.random.normal(24, 4, n_samples).clip(16, 40)
age = np.random.normal(35, 10, n_samples).clip(18, 65)
exercise_minutes = np.random.normal(30, 20, n_samples).clip(0, 120)
alcohol_units = np.random.poisson(0.7, n_samples).clip(0, 10)
caffeine_mg = np.random.normal(150, 50, n_samples).clip(0, 400)

# Probabilistic target generation
stress_prob = (
    (heart_rate - 60)/60 +
    (screen_time - 4)/6 -
    (sleep_hours - 6)/6 -
    (hydration - 2)/2 +
    (bmi - 25)/10 +
    (alcohol_units)/5 +
    (caffeine_mg - 100)/200 -
    (exercise_minutes)/60
)

# Sigmoid + label
stress_prob = 1 / (1 + np.exp(-stress_prob))
stress_level = (stress_prob > 0.5).astype(int)

# DataFrame
df = pd.DataFrame({
    "heart_rate": np.round(heart_rate, 1),
    "sleep_hours": np.round(sleep_hours, 1),
    "steps": np.round(steps),
    "calories": np.round(calories),
    "screen_time": np.round(screen_time, 1),
    "hydration": np.round(hydration, 1),
    "bmi": np.round(bmi, 1),
    "age": np.round(age),
    "exercise_minutes": np.round(exercise_minutes),
    "alcohol_units": alcohol_units,
    "caffeine_mg": np.round(caffeine_mg),
    "stress_level": stress_level
})

# Save
df.to_csv("simulated_wellness_data.csv", index=False)
df.head()

df.to_csv("simulated_wellness_data.csv", index=False)

model = xgb.XGBClassifier(
    use_label_encoder=False,
    eval_metric='logloss',
    max_depth=3,
    n_estimators=100,
    learning_rate=0.05,
    subsample=0.8,
    colsample_bytree=0.8,
    reg_alpha=0.5,    # L1 regularization
    reg_lambda=1.0    # L2 regularization
)



pip install --upgrade xgboost

import pandas as pd
import xgboost as xgb
from sklearn.model_selection import train_test_split
from sklearn.metrics import classification_report, roc_auc_score

# Load dataset
df = pd.read_csv("simulated_wellness_data.csv")
X = df.drop("stress_level", axis=1)
y = df["stress_level"]

# Split into train/test/validation
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
X_train_sub, X_val, y_train_sub, y_val = train_test_split(X_train, y_train, test_size=0.2, random_state=42)

# Convert to DMatrix
dtrain = xgb.DMatrix(X_train_sub, label=y_train_sub)
dval = xgb.DMatrix(X_val, label=y_val)
dtest = xgb.DMatrix(X_test)

# Set parameters
params = {
    "objective": "binary:logistic",
    "eval_metric": "logloss",
    "max_depth": 3,
    "eta": 0.05,
    "subsample": 0.8,
    "colsample_bytree": 0.8,
    "reg_alpha": 0.5,
    "reg_lambda": 1.0,
    "verbosity": 0
}

# Train with early stopping
evals = [(dtrain, "train"), (dval, "eval")]
model = xgb.train(params, dtrain, num_boost_round=300, evals=evals, early_stopping_rounds=10)

# Predict on test set
y_prob = model.predict(dtest)
y_pred = (y_prob > 0.45).astype(int)

# Evaluate
print(classification_report(y_test, y_pred))
print("AUC Score:", roc_auc_score(y_test, y_prob))

# Save model
model.save_model("wellness_model.json")  # Save in XGBoost native format





